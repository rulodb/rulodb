// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.3
// source: rulo.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export enum ProtocolVersion {
  VERSION_1 = 0,
  UNRECOGNIZED = -1,
}

export enum MessageType {
  /** QUERY - Core query/response cycle */
  QUERY = 0,
  RESPONSE = 1,
  ERROR = 2,
  /** AUTH_INIT - Authentication flow */
  AUTH_INIT = 3,
  AUTH_CHALLENGE = 4,
  AUTH_RESPONSE = 5,
  AUTH_OK = 6,
  /** PING - Administrative */
  PING = 14,
  PONG = 15,
  QUERY_PLAN = 16,
  UNRECOGNIZED = -1,
}

export enum NullValue {
  NULL_VALUE = 0,
  UNRECOGNIZED = -1,
}

export enum SortDirection {
  ASC = 0,
  DESC = 1,
  UNRECOGNIZED = -1,
}

/** Envelope is the universal message wrapper for all RuloDB communication. */
export interface Envelope {
  /** Protocol version */
  version: ProtocolVersion;
  /** Unique identifier for request correlation */
  queryId: string;
  /** Message type discriminator */
  type: MessageType;
  /** Serialized message content */
  payload: Uint8Array;
}

export interface AuthInit {
  username: string;
}

export interface AuthChallenge {
  challenge: string;
  nonce: Uint8Array;
}

export interface AuthResponse {
  proof: Uint8Array;
}

export interface AuthOk {
  sessionToken: string;
  /** Unix timestamp */
  expiresAt: string;
  permissions: string[];
}

export interface AuthResult {
  success: boolean;
  sessionToken: string;
  expiresAt: string;
  permissions: string[];
}

export interface DatabaseRef {
  name: string;
}

export interface TableRef {
  database?: DatabaseRef | undefined;
  name: string;
}

export interface FieldRef {
  path: string[];
  separator: string;
}

export interface Datum {
  bool?: boolean | undefined;
  int?: string | undefined;
  float?: number | undefined;
  string?: string | undefined;
  binary?: Uint8Array | undefined;
  object?: DatumObject | undefined;
  array?: DatumArray | undefined;
  null?: NullValue | undefined;
}

export interface DatumObject {
  fields: { [key: string]: Datum };
}

export interface DatumObject_FieldsEntry {
  key: string;
  value?: Datum | undefined;
}

export interface DatumArray {
  items: Datum[];
  elementType: string;
}

export interface SortField {
  fieldName: string;
  direction: SortDirection;
}

export interface SortOptions {
  fields: SortField[];
}

export interface Cursor {
  startKey?: string | undefined;
  batchSize?: number | undefined;
  sort?: SortOptions | undefined;
}

export interface QueryOptions {
  timeoutMs: number;
  explain: boolean;
}

export interface Query {
  options?: QueryOptions | undefined;
  cursor?:
    | Cursor
    | undefined;
  /** Data Manipulation */
  insert?: Insert | undefined;
  delete?: Delete | undefined;
  update?:
    | Update
    | undefined;
  /** Querying & Data Retrieval */
  table?: Table | undefined;
  get?: Get | undefined;
  getAll?: GetAll | undefined;
  filter?:
    | Filter
    | undefined;
  /** Transformations */
  orderBy?: OrderBy | undefined;
  limit?: Limit | undefined;
  skip?:
    | Skip
    | undefined;
  /** Aggregation & Grouping */
  count?:
    | Count
    | undefined;
  /** Document Manipulation */
  pluck?:
    | Pluck
    | undefined;
  /** Schema & Data Modeling */
  tableCreate?: TableCreate | undefined;
  tableDrop?: TableDrop | undefined;
  databaseCreate?: DatabaseCreate | undefined;
  databaseDrop?: DatabaseDrop | undefined;
  tableList?: TableList | undefined;
  databaseList?:
    | DatabaseList
    | undefined;
  /** Control & Execution */
  expression?: Expression | undefined;
  subquery?: Subquery | undefined;
}

/** Data Retrieval */
export interface Table {
  table?: TableRef | undefined;
}

export interface Get {
  source?: Query | undefined;
  key?: Datum | undefined;
}

export interface GetAll {
  source?: Query | undefined;
  keys: Datum[];
}

export interface Filter {
  source?: Query | undefined;
  predicate?: Expression | undefined;
}

export interface OrderBy {
  source?: Query | undefined;
  fields: SortField[];
}

export interface Limit {
  source?: Query | undefined;
  count: number;
}

export interface Skip {
  source?: Query | undefined;
  count: number;
}

export interface Count {
  source?: Query | undefined;
}

export interface Pluck {
  source?: Query | undefined;
  fields: FieldRef[];
}

/** Data Manipulation */
export interface Insert {
  source?: Query | undefined;
  documents: DatumObject[];
}

export interface Delete {
  source?: Query | undefined;
}

export interface Update {
  source?: Query | undefined;
  patch?: DatumObject | undefined;
}

/** Schema Operations */
export interface DatabaseCreate {
  name: string;
}

export interface DatabaseDrop {
  name: string;
}

export interface DatabaseList {
}

export interface TableCreate {
  table?: TableRef | undefined;
}

export interface TableDrop {
  table?: TableRef | undefined;
}

export interface TableList {
  database?: DatabaseRef | undefined;
}

export interface Expression {
  literal?: Datum | undefined;
  field?: FieldRef | undefined;
  variable?: Variable | undefined;
  binary?: BinaryOp | undefined;
  unary?: UnaryOp | undefined;
  match?: MatchExpr | undefined;
  subquery?: Query | undefined;
}

export interface Variable {
  name: string;
}

export interface BinaryOp {
  op: BinaryOp_Operator;
  left?: Expression | undefined;
  right?: Expression | undefined;
}

export enum BinaryOp_Operator {
  EQ = 0,
  NE = 1,
  LT = 2,
  LE = 3,
  GT = 4,
  GE = 5,
  AND = 6,
  OR = 7,
  UNRECOGNIZED = -1,
}

export interface UnaryOp {
  op: UnaryOp_Operator;
  expr?: Expression | undefined;
}

export enum UnaryOp_Operator {
  NOT = 0,
  UNRECOGNIZED = -1,
}

export interface MatchExpr {
  value?: Expression | undefined;
  pattern: string;
  flags: string;
}

export interface Subquery {
  query?: Query | undefined;
}

export interface Response {
  metadata?: ResponseMetadata | undefined;
  query?: QueryResult | undefined;
  error?: ErrorInfo | undefined;
  authResult?: AuthResult | undefined;
  pong?: PingResult | undefined;
  plan?: QueryPlan | undefined;
}

export interface ResponseMetadata {
  queryId: string;
  timestamp: string;
  serverVersion: string;
}

export interface ErrorInfo {
  code: number;
  message: string;
  type: string;
  line: number;
  column: number;
}

export interface QueryResult {
  literal?: LiteralResult | undefined;
  get?: GetResult | undefined;
  getAll?: GetAllResult | undefined;
  table?: TableScanResult | undefined;
  filter?: FilterResult | undefined;
  orderBy?: OrderByResult | undefined;
  limit?: LimitResult | undefined;
  skip?: SkipResult | undefined;
  count?: CountResult | undefined;
  pluck?: PluckResult | undefined;
  insert?: InsertResult | undefined;
  delete?: DeleteResult | undefined;
  update?: UpdateResult | undefined;
  databaseCreate?: DatabaseCreateResult | undefined;
  databaseDrop?: DatabaseDropResult | undefined;
  databaseList?: DatabaseListResult | undefined;
  tableCreate?: TableCreateResult | undefined;
  tableDrop?: TableDropResult | undefined;
  tableList?: TableListResult | undefined;
}

export interface LiteralResult {
  value?: Datum | undefined;
}

/** Retrieval Results */
export interface GetResult {
  document?: Datum | undefined;
}

export interface GetAllResult {
  documents: Datum[];
  cursor?: Cursor | undefined;
}

export interface TableScanResult {
  documents: Datum[];
  cursor?: Cursor | undefined;
}

export interface FilterResult {
  documents: Datum[];
  cursor?: Cursor | undefined;
}

export interface OrderByResult {
  documents: Datum[];
  cursor?: Cursor | undefined;
}

export interface LimitResult {
  documents: Datum[];
  cursor?: Cursor | undefined;
}

export interface SkipResult {
  documents: Datum[];
  cursor?: Cursor | undefined;
}

export interface CountResult {
  count: string;
}

export interface PluckResult {
  documents: Datum[];
  cursor?: Cursor | undefined;
}

/** Manipulation Results */
export interface InsertResult {
  inserted: string;
  generatedKeys: Datum[];
}

export interface DeleteResult {
  deleted: string;
}

export interface UpdateResult {
  updated: string;
}

/** Schema Results */
export interface DatabaseCreateResult {
  created: string;
}

export interface DatabaseDropResult {
  dropped: string;
}

export interface DatabaseListResult {
  databases: string[];
  cursor?: Cursor | undefined;
}

export interface TableCreateResult {
  created: string;
}

export interface TableDropResult {
  dropped: string;
}

export interface TableListResult {
  tables: string[];
  cursor?: Cursor | undefined;
}

export interface PingResult {
  timestamp: string;
  latencyMs: number;
}

export interface QueryPlan {
  nodes: PlanNode[];
  statistics?: PlanStatistics | undefined;
}

export interface PlanNode {
  operation: string;
  properties: { [key: string]: string };
  children: PlanNode[];
  estimatedCost: number;
  estimatedRows: string;
}

export interface PlanNode_PropertiesEntry {
  key: string;
  value: string;
}

export interface PlanStatistics {
  planningTimeMs: number;
  executionTimeMs: number;
  rowsExamined: string;
  rowsReturned: string;
  bytesRead: string;
}

function createBaseEnvelope(): Envelope {
  return { version: 0, queryId: "", type: 0, payload: new Uint8Array(0) };
}

export const Envelope: MessageFns<Envelope> = {
  encode(message: Envelope, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).int32(message.version);
    }
    if (message.queryId !== "") {
      writer.uint32(18).string(message.queryId);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.payload.length !== 0) {
      writer.uint32(34).bytes(message.payload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Envelope {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.queryId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Envelope>): Envelope {
    return Envelope.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Envelope>): Envelope {
    const message = createBaseEnvelope();
    message.version = object.version ?? 0;
    message.queryId = object.queryId ?? "";
    message.type = object.type ?? 0;
    message.payload = object.payload ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAuthInit(): AuthInit {
  return { username: "" };
}

export const AuthInit: MessageFns<AuthInit> = {
  encode(message: AuthInit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthInit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthInit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AuthInit>): AuthInit {
    return AuthInit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthInit>): AuthInit {
    const message = createBaseAuthInit();
    message.username = object.username ?? "";
    return message;
  },
};

function createBaseAuthChallenge(): AuthChallenge {
  return { challenge: "", nonce: new Uint8Array(0) };
}

export const AuthChallenge: MessageFns<AuthChallenge> = {
  encode(message: AuthChallenge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.challenge !== "") {
      writer.uint32(10).string(message.challenge);
    }
    if (message.nonce.length !== 0) {
      writer.uint32(18).bytes(message.nonce);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthChallenge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthChallenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.challenge = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AuthChallenge>): AuthChallenge {
    return AuthChallenge.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthChallenge>): AuthChallenge {
    const message = createBaseAuthChallenge();
    message.challenge = object.challenge ?? "";
    message.nonce = object.nonce ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAuthResponse(): AuthResponse {
  return { proof: new Uint8Array(0) };
}

export const AuthResponse: MessageFns<AuthResponse> = {
  encode(message: AuthResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proof.length !== 0) {
      writer.uint32(10).bytes(message.proof);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proof = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AuthResponse>): AuthResponse {
    return AuthResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthResponse>): AuthResponse {
    const message = createBaseAuthResponse();
    message.proof = object.proof ?? new Uint8Array(0);
    return message;
  },
};

function createBaseAuthOk(): AuthOk {
  return { sessionToken: "", expiresAt: "0", permissions: [] };
}

export const AuthOk: MessageFns<AuthOk> = {
  encode(message: AuthOk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionToken !== "") {
      writer.uint32(10).string(message.sessionToken);
    }
    if (message.expiresAt !== "0") {
      writer.uint32(16).uint64(message.expiresAt);
    }
    for (const v of message.permissions) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthOk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthOk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.expiresAt = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.permissions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AuthOk>): AuthOk {
    return AuthOk.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthOk>): AuthOk {
    const message = createBaseAuthOk();
    message.sessionToken = object.sessionToken ?? "";
    message.expiresAt = object.expiresAt ?? "0";
    message.permissions = object.permissions?.map((e) => e) || [];
    return message;
  },
};

function createBaseAuthResult(): AuthResult {
  return { success: false, sessionToken: "", expiresAt: "0", permissions: [] };
}

export const AuthResult: MessageFns<AuthResult> = {
  encode(message: AuthResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.sessionToken !== "") {
      writer.uint32(18).string(message.sessionToken);
    }
    if (message.expiresAt !== "0") {
      writer.uint32(24).uint64(message.expiresAt);
    }
    for (const v of message.permissions) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionToken = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.expiresAt = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.permissions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AuthResult>): AuthResult {
    return AuthResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AuthResult>): AuthResult {
    const message = createBaseAuthResult();
    message.success = object.success ?? false;
    message.sessionToken = object.sessionToken ?? "";
    message.expiresAt = object.expiresAt ?? "0";
    message.permissions = object.permissions?.map((e) => e) || [];
    return message;
  },
};

function createBaseDatabaseRef(): DatabaseRef {
  return { name: "" };
}

export const DatabaseRef: MessageFns<DatabaseRef> = {
  encode(message: DatabaseRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DatabaseRef>): DatabaseRef {
    return DatabaseRef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatabaseRef>): DatabaseRef {
    const message = createBaseDatabaseRef();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseTableRef(): TableRef {
  return { database: undefined, name: "" };
}

export const TableRef: MessageFns<TableRef> = {
  encode(message: TableRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.database !== undefined) {
      DatabaseRef.encode(message.database, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.database = DatabaseRef.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TableRef>): TableRef {
    return TableRef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableRef>): TableRef {
    const message = createBaseTableRef();
    message.database = (object.database !== undefined && object.database !== null)
      ? DatabaseRef.fromPartial(object.database)
      : undefined;
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseFieldRef(): FieldRef {
  return { path: [], separator: "" };
}

export const FieldRef: MessageFns<FieldRef> = {
  encode(message: FieldRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.path) {
      writer.uint32(10).string(v!);
    }
    if (message.separator !== "") {
      writer.uint32(18).string(message.separator);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.separator = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<FieldRef>): FieldRef {
    return FieldRef.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FieldRef>): FieldRef {
    const message = createBaseFieldRef();
    message.path = object.path?.map((e) => e) || [];
    message.separator = object.separator ?? "";
    return message;
  },
};

function createBaseDatum(): Datum {
  return {
    bool: undefined,
    int: undefined,
    float: undefined,
    string: undefined,
    binary: undefined,
    object: undefined,
    array: undefined,
    null: undefined,
  };
}

export const Datum: MessageFns<Datum> = {
  encode(message: Datum, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bool !== undefined) {
      writer.uint32(8).bool(message.bool);
    }
    if (message.int !== undefined) {
      writer.uint32(16).int64(message.int);
    }
    if (message.float !== undefined) {
      writer.uint32(25).double(message.float);
    }
    if (message.string !== undefined) {
      writer.uint32(34).string(message.string);
    }
    if (message.binary !== undefined) {
      writer.uint32(42).bytes(message.binary);
    }
    if (message.object !== undefined) {
      DatumObject.encode(message.object, writer.uint32(50).fork()).join();
    }
    if (message.array !== undefined) {
      DatumArray.encode(message.array, writer.uint32(58).fork()).join();
    }
    if (message.null !== undefined) {
      writer.uint32(104).int32(message.null);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Datum {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatum();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.bool = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.int = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.float = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.string = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.binary = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.object = DatumObject.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.array = DatumArray.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.null = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Datum>): Datum {
    return Datum.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Datum>): Datum {
    const message = createBaseDatum();
    message.bool = object.bool ?? undefined;
    message.int = object.int ?? undefined;
    message.float = object.float ?? undefined;
    message.string = object.string ?? undefined;
    message.binary = object.binary ?? undefined;
    message.object = (object.object !== undefined && object.object !== null)
      ? DatumObject.fromPartial(object.object)
      : undefined;
    message.array = (object.array !== undefined && object.array !== null)
      ? DatumArray.fromPartial(object.array)
      : undefined;
    message.null = object.null ?? undefined;
    return message;
  },
};

function createBaseDatumObject(): DatumObject {
  return { fields: {} };
}

export const DatumObject: MessageFns<DatumObject> = {
  encode(message: DatumObject, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.fields).forEach(([key, value]) => {
      DatumObject_FieldsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatumObject {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatumObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = DatumObject_FieldsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.fields[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DatumObject>): DatumObject {
    return DatumObject.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatumObject>): DatumObject {
    const message = createBaseDatumObject();
    message.fields = Object.entries(object.fields ?? {}).reduce<{ [key: string]: Datum }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Datum.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseDatumObject_FieldsEntry(): DatumObject_FieldsEntry {
  return { key: "", value: undefined };
}

export const DatumObject_FieldsEntry: MessageFns<DatumObject_FieldsEntry> = {
  encode(message: DatumObject_FieldsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Datum.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatumObject_FieldsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatumObject_FieldsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Datum.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DatumObject_FieldsEntry>): DatumObject_FieldsEntry {
    return DatumObject_FieldsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatumObject_FieldsEntry>): DatumObject_FieldsEntry {
    const message = createBaseDatumObject_FieldsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null) ? Datum.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseDatumArray(): DatumArray {
  return { items: [], elementType: "" };
}

export const DatumArray: MessageFns<DatumArray> = {
  encode(message: DatumArray, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      Datum.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.elementType !== "") {
      writer.uint32(18).string(message.elementType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatumArray {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatumArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(Datum.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.elementType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DatumArray>): DatumArray {
    return DatumArray.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatumArray>): DatumArray {
    const message = createBaseDatumArray();
    message.items = object.items?.map((e) => Datum.fromPartial(e)) || [];
    message.elementType = object.elementType ?? "";
    return message;
  },
};

function createBaseSortField(): SortField {
  return { fieldName: "", direction: 0 };
}

export const SortField: MessageFns<SortField> = {
  encode(message: SortField, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fieldName !== "") {
      writer.uint32(10).string(message.fieldName);
    }
    if (message.direction !== 0) {
      writer.uint32(16).int32(message.direction);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SortField {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSortField();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fieldName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SortField>): SortField {
    return SortField.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SortField>): SortField {
    const message = createBaseSortField();
    message.fieldName = object.fieldName ?? "";
    message.direction = object.direction ?? 0;
    return message;
  },
};

function createBaseSortOptions(): SortOptions {
  return { fields: [] };
}

export const SortOptions: MessageFns<SortOptions> = {
  encode(message: SortOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fields) {
      SortField.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SortOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSortOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fields.push(SortField.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SortOptions>): SortOptions {
    return SortOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SortOptions>): SortOptions {
    const message = createBaseSortOptions();
    message.fields = object.fields?.map((e) => SortField.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCursor(): Cursor {
  return { startKey: undefined, batchSize: undefined, sort: undefined };
}

export const Cursor: MessageFns<Cursor> = {
  encode(message: Cursor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startKey !== undefined) {
      writer.uint32(10).string(message.startKey);
    }
    if (message.batchSize !== undefined) {
      writer.uint32(24).uint32(message.batchSize);
    }
    if (message.sort !== undefined) {
      SortOptions.encode(message.sort, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cursor {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCursor();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.startKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.batchSize = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sort = SortOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Cursor>): Cursor {
    return Cursor.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Cursor>): Cursor {
    const message = createBaseCursor();
    message.startKey = object.startKey ?? undefined;
    message.batchSize = object.batchSize ?? undefined;
    message.sort = (object.sort !== undefined && object.sort !== null)
      ? SortOptions.fromPartial(object.sort)
      : undefined;
    return message;
  },
};

function createBaseQueryOptions(): QueryOptions {
  return { timeoutMs: 0, explain: false };
}

export const QueryOptions: MessageFns<QueryOptions> = {
  encode(message: QueryOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeoutMs !== 0) {
      writer.uint32(8).uint32(message.timeoutMs);
    }
    if (message.explain !== false) {
      writer.uint32(16).bool(message.explain);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timeoutMs = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.explain = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<QueryOptions>): QueryOptions {
    return QueryOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryOptions>): QueryOptions {
    const message = createBaseQueryOptions();
    message.timeoutMs = object.timeoutMs ?? 0;
    message.explain = object.explain ?? false;
    return message;
  },
};

function createBaseQuery(): Query {
  return {
    options: undefined,
    cursor: undefined,
    insert: undefined,
    delete: undefined,
    update: undefined,
    table: undefined,
    get: undefined,
    getAll: undefined,
    filter: undefined,
    orderBy: undefined,
    limit: undefined,
    skip: undefined,
    count: undefined,
    pluck: undefined,
    tableCreate: undefined,
    tableDrop: undefined,
    databaseCreate: undefined,
    databaseDrop: undefined,
    tableList: undefined,
    databaseList: undefined,
    expression: undefined,
    subquery: undefined,
  };
}

export const Query: MessageFns<Query> = {
  encode(message: Query, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.options !== undefined) {
      QueryOptions.encode(message.options, writer.uint32(10).fork()).join();
    }
    if (message.cursor !== undefined) {
      Cursor.encode(message.cursor, writer.uint32(18).fork()).join();
    }
    if (message.insert !== undefined) {
      Insert.encode(message.insert, writer.uint32(26).fork()).join();
    }
    if (message.delete !== undefined) {
      Delete.encode(message.delete, writer.uint32(34).fork()).join();
    }
    if (message.update !== undefined) {
      Update.encode(message.update, writer.uint32(42).fork()).join();
    }
    if (message.table !== undefined) {
      Table.encode(message.table, writer.uint32(50).fork()).join();
    }
    if (message.get !== undefined) {
      Get.encode(message.get, writer.uint32(58).fork()).join();
    }
    if (message.getAll !== undefined) {
      GetAll.encode(message.getAll, writer.uint32(66).fork()).join();
    }
    if (message.filter !== undefined) {
      Filter.encode(message.filter, writer.uint32(74).fork()).join();
    }
    if (message.orderBy !== undefined) {
      OrderBy.encode(message.orderBy, writer.uint32(82).fork()).join();
    }
    if (message.limit !== undefined) {
      Limit.encode(message.limit, writer.uint32(90).fork()).join();
    }
    if (message.skip !== undefined) {
      Skip.encode(message.skip, writer.uint32(98).fork()).join();
    }
    if (message.count !== undefined) {
      Count.encode(message.count, writer.uint32(106).fork()).join();
    }
    if (message.pluck !== undefined) {
      Pluck.encode(message.pluck, writer.uint32(178).fork()).join();
    }
    if (message.tableCreate !== undefined) {
      TableCreate.encode(message.tableCreate, writer.uint32(114).fork()).join();
    }
    if (message.tableDrop !== undefined) {
      TableDrop.encode(message.tableDrop, writer.uint32(122).fork()).join();
    }
    if (message.databaseCreate !== undefined) {
      DatabaseCreate.encode(message.databaseCreate, writer.uint32(130).fork()).join();
    }
    if (message.databaseDrop !== undefined) {
      DatabaseDrop.encode(message.databaseDrop, writer.uint32(138).fork()).join();
    }
    if (message.tableList !== undefined) {
      TableList.encode(message.tableList, writer.uint32(146).fork()).join();
    }
    if (message.databaseList !== undefined) {
      DatabaseList.encode(message.databaseList, writer.uint32(154).fork()).join();
    }
    if (message.expression !== undefined) {
      Expression.encode(message.expression, writer.uint32(162).fork()).join();
    }
    if (message.subquery !== undefined) {
      Subquery.encode(message.subquery, writer.uint32(170).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Query {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQuery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.options = QueryOptions.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cursor = Cursor.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.insert = Insert.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.delete = Delete.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.update = Update.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.table = Table.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.get = Get.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.getAll = GetAll.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.filter = Filter.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.orderBy = OrderBy.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.limit = Limit.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.skip = Skip.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.count = Count.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.pluck = Pluck.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.tableCreate = TableCreate.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.tableDrop = TableDrop.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.databaseCreate = DatabaseCreate.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.databaseDrop = DatabaseDrop.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.tableList = TableList.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.databaseList = DatabaseList.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.expression = Expression.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.subquery = Subquery.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Query>): Query {
    return Query.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Query>): Query {
    const message = createBaseQuery();
    message.options = (object.options !== undefined && object.options !== null)
      ? QueryOptions.fromPartial(object.options)
      : undefined;
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? Cursor.fromPartial(object.cursor)
      : undefined;
    message.insert = (object.insert !== undefined && object.insert !== null)
      ? Insert.fromPartial(object.insert)
      : undefined;
    message.delete = (object.delete !== undefined && object.delete !== null)
      ? Delete.fromPartial(object.delete)
      : undefined;
    message.update = (object.update !== undefined && object.update !== null)
      ? Update.fromPartial(object.update)
      : undefined;
    message.table = (object.table !== undefined && object.table !== null) ? Table.fromPartial(object.table) : undefined;
    message.get = (object.get !== undefined && object.get !== null) ? Get.fromPartial(object.get) : undefined;
    message.getAll = (object.getAll !== undefined && object.getAll !== null)
      ? GetAll.fromPartial(object.getAll)
      : undefined;
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? Filter.fromPartial(object.filter)
      : undefined;
    message.orderBy = (object.orderBy !== undefined && object.orderBy !== null)
      ? OrderBy.fromPartial(object.orderBy)
      : undefined;
    message.limit = (object.limit !== undefined && object.limit !== null) ? Limit.fromPartial(object.limit) : undefined;
    message.skip = (object.skip !== undefined && object.skip !== null) ? Skip.fromPartial(object.skip) : undefined;
    message.count = (object.count !== undefined && object.count !== null) ? Count.fromPartial(object.count) : undefined;
    message.pluck = (object.pluck !== undefined && object.pluck !== null) ? Pluck.fromPartial(object.pluck) : undefined;
    message.tableCreate = (object.tableCreate !== undefined && object.tableCreate !== null)
      ? TableCreate.fromPartial(object.tableCreate)
      : undefined;
    message.tableDrop = (object.tableDrop !== undefined && object.tableDrop !== null)
      ? TableDrop.fromPartial(object.tableDrop)
      : undefined;
    message.databaseCreate = (object.databaseCreate !== undefined && object.databaseCreate !== null)
      ? DatabaseCreate.fromPartial(object.databaseCreate)
      : undefined;
    message.databaseDrop = (object.databaseDrop !== undefined && object.databaseDrop !== null)
      ? DatabaseDrop.fromPartial(object.databaseDrop)
      : undefined;
    message.tableList = (object.tableList !== undefined && object.tableList !== null)
      ? TableList.fromPartial(object.tableList)
      : undefined;
    message.databaseList = (object.databaseList !== undefined && object.databaseList !== null)
      ? DatabaseList.fromPartial(object.databaseList)
      : undefined;
    message.expression = (object.expression !== undefined && object.expression !== null)
      ? Expression.fromPartial(object.expression)
      : undefined;
    message.subquery = (object.subquery !== undefined && object.subquery !== null)
      ? Subquery.fromPartial(object.subquery)
      : undefined;
    return message;
  },
};

function createBaseTable(): Table {
  return { table: undefined };
}

export const Table: MessageFns<Table> = {
  encode(message: Table, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.table !== undefined) {
      TableRef.encode(message.table, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Table {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.table = TableRef.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Table>): Table {
    return Table.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Table>): Table {
    const message = createBaseTable();
    message.table = (object.table !== undefined && object.table !== null)
      ? TableRef.fromPartial(object.table)
      : undefined;
    return message;
  },
};

function createBaseGet(): Get {
  return { source: undefined, key: undefined };
}

export const Get: MessageFns<Get> = {
  encode(message: Get, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== undefined) {
      Query.encode(message.source, writer.uint32(10).fork()).join();
    }
    if (message.key !== undefined) {
      Datum.encode(message.key, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Get {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = Query.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.key = Datum.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Get>): Get {
    return Get.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Get>): Get {
    const message = createBaseGet();
    message.source = (object.source !== undefined && object.source !== null)
      ? Query.fromPartial(object.source)
      : undefined;
    message.key = (object.key !== undefined && object.key !== null) ? Datum.fromPartial(object.key) : undefined;
    return message;
  },
};

function createBaseGetAll(): GetAll {
  return { source: undefined, keys: [] };
}

export const GetAll: MessageFns<GetAll> = {
  encode(message: GetAll, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== undefined) {
      Query.encode(message.source, writer.uint32(10).fork()).join();
    }
    for (const v of message.keys) {
      Datum.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAll {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAll();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = Query.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keys.push(Datum.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetAll>): GetAll {
    return GetAll.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAll>): GetAll {
    const message = createBaseGetAll();
    message.source = (object.source !== undefined && object.source !== null)
      ? Query.fromPartial(object.source)
      : undefined;
    message.keys = object.keys?.map((e) => Datum.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFilter(): Filter {
  return { source: undefined, predicate: undefined };
}

export const Filter: MessageFns<Filter> = {
  encode(message: Filter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== undefined) {
      Query.encode(message.source, writer.uint32(10).fork()).join();
    }
    if (message.predicate !== undefined) {
      Expression.encode(message.predicate, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Filter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = Query.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.predicate = Expression.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Filter>): Filter {
    return Filter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Filter>): Filter {
    const message = createBaseFilter();
    message.source = (object.source !== undefined && object.source !== null)
      ? Query.fromPartial(object.source)
      : undefined;
    message.predicate = (object.predicate !== undefined && object.predicate !== null)
      ? Expression.fromPartial(object.predicate)
      : undefined;
    return message;
  },
};

function createBaseOrderBy(): OrderBy {
  return { source: undefined, fields: [] };
}

export const OrderBy: MessageFns<OrderBy> = {
  encode(message: OrderBy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== undefined) {
      Query.encode(message.source, writer.uint32(10).fork()).join();
    }
    for (const v of message.fields) {
      SortField.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderBy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderBy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = Query.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fields.push(SortField.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<OrderBy>): OrderBy {
    return OrderBy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrderBy>): OrderBy {
    const message = createBaseOrderBy();
    message.source = (object.source !== undefined && object.source !== null)
      ? Query.fromPartial(object.source)
      : undefined;
    message.fields = object.fields?.map((e) => SortField.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLimit(): Limit {
  return { source: undefined, count: 0 };
}

export const Limit: MessageFns<Limit> = {
  encode(message: Limit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== undefined) {
      Query.encode(message.source, writer.uint32(10).fork()).join();
    }
    if (message.count !== 0) {
      writer.uint32(16).uint32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Limit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLimit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = Query.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Limit>): Limit {
    return Limit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Limit>): Limit {
    const message = createBaseLimit();
    message.source = (object.source !== undefined && object.source !== null)
      ? Query.fromPartial(object.source)
      : undefined;
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseSkip(): Skip {
  return { source: undefined, count: 0 };
}

export const Skip: MessageFns<Skip> = {
  encode(message: Skip, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== undefined) {
      Query.encode(message.source, writer.uint32(10).fork()).join();
    }
    if (message.count !== 0) {
      writer.uint32(16).uint32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Skip {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkip();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = Query.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Skip>): Skip {
    return Skip.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Skip>): Skip {
    const message = createBaseSkip();
    message.source = (object.source !== undefined && object.source !== null)
      ? Query.fromPartial(object.source)
      : undefined;
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseCount(): Count {
  return { source: undefined };
}

export const Count: MessageFns<Count> = {
  encode(message: Count, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== undefined) {
      Query.encode(message.source, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Count {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCount();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = Query.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Count>): Count {
    return Count.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Count>): Count {
    const message = createBaseCount();
    message.source = (object.source !== undefined && object.source !== null)
      ? Query.fromPartial(object.source)
      : undefined;
    return message;
  },
};

function createBasePluck(): Pluck {
  return { source: undefined, fields: [] };
}

export const Pluck: MessageFns<Pluck> = {
  encode(message: Pluck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== undefined) {
      Query.encode(message.source, writer.uint32(10).fork()).join();
    }
    for (const v of message.fields) {
      FieldRef.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pluck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePluck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = Query.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fields.push(FieldRef.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Pluck>): Pluck {
    return Pluck.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Pluck>): Pluck {
    const message = createBasePluck();
    message.source = (object.source !== undefined && object.source !== null)
      ? Query.fromPartial(object.source)
      : undefined;
    message.fields = object.fields?.map((e) => FieldRef.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInsert(): Insert {
  return { source: undefined, documents: [] };
}

export const Insert: MessageFns<Insert> = {
  encode(message: Insert, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== undefined) {
      Query.encode(message.source, writer.uint32(10).fork()).join();
    }
    for (const v of message.documents) {
      DatumObject.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Insert {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = Query.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.documents.push(DatumObject.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Insert>): Insert {
    return Insert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Insert>): Insert {
    const message = createBaseInsert();
    message.source = (object.source !== undefined && object.source !== null)
      ? Query.fromPartial(object.source)
      : undefined;
    message.documents = object.documents?.map((e) => DatumObject.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDelete(): Delete {
  return { source: undefined };
}

export const Delete: MessageFns<Delete> = {
  encode(message: Delete, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== undefined) {
      Query.encode(message.source, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Delete {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelete();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = Query.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Delete>): Delete {
    return Delete.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Delete>): Delete {
    const message = createBaseDelete();
    message.source = (object.source !== undefined && object.source !== null)
      ? Query.fromPartial(object.source)
      : undefined;
    return message;
  },
};

function createBaseUpdate(): Update {
  return { source: undefined, patch: undefined };
}

export const Update: MessageFns<Update> = {
  encode(message: Update, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== undefined) {
      Query.encode(message.source, writer.uint32(10).fork()).join();
    }
    if (message.patch !== undefined) {
      DatumObject.encode(message.patch, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Update {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.source = Query.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.patch = DatumObject.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Update>): Update {
    return Update.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Update>): Update {
    const message = createBaseUpdate();
    message.source = (object.source !== undefined && object.source !== null)
      ? Query.fromPartial(object.source)
      : undefined;
    message.patch = (object.patch !== undefined && object.patch !== null)
      ? DatumObject.fromPartial(object.patch)
      : undefined;
    return message;
  },
};

function createBaseDatabaseCreate(): DatabaseCreate {
  return { name: "" };
}

export const DatabaseCreate: MessageFns<DatabaseCreate> = {
  encode(message: DatabaseCreate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseCreate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DatabaseCreate>): DatabaseCreate {
    return DatabaseCreate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatabaseCreate>): DatabaseCreate {
    const message = createBaseDatabaseCreate();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDatabaseDrop(): DatabaseDrop {
  return { name: "" };
}

export const DatabaseDrop: MessageFns<DatabaseDrop> = {
  encode(message: DatabaseDrop, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseDrop {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseDrop();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DatabaseDrop>): DatabaseDrop {
    return DatabaseDrop.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatabaseDrop>): DatabaseDrop {
    const message = createBaseDatabaseDrop();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseDatabaseList(): DatabaseList {
  return {};
}

export const DatabaseList: MessageFns<DatabaseList> = {
  encode(_: DatabaseList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DatabaseList>): DatabaseList {
    return DatabaseList.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DatabaseList>): DatabaseList {
    const message = createBaseDatabaseList();
    return message;
  },
};

function createBaseTableCreate(): TableCreate {
  return { table: undefined };
}

export const TableCreate: MessageFns<TableCreate> = {
  encode(message: TableCreate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.table !== undefined) {
      TableRef.encode(message.table, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableCreate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableCreate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.table = TableRef.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TableCreate>): TableCreate {
    return TableCreate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableCreate>): TableCreate {
    const message = createBaseTableCreate();
    message.table = (object.table !== undefined && object.table !== null)
      ? TableRef.fromPartial(object.table)
      : undefined;
    return message;
  },
};

function createBaseTableDrop(): TableDrop {
  return { table: undefined };
}

export const TableDrop: MessageFns<TableDrop> = {
  encode(message: TableDrop, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.table !== undefined) {
      TableRef.encode(message.table, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableDrop {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableDrop();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.table = TableRef.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TableDrop>): TableDrop {
    return TableDrop.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableDrop>): TableDrop {
    const message = createBaseTableDrop();
    message.table = (object.table !== undefined && object.table !== null)
      ? TableRef.fromPartial(object.table)
      : undefined;
    return message;
  },
};

function createBaseTableList(): TableList {
  return { database: undefined };
}

export const TableList: MessageFns<TableList> = {
  encode(message: TableList, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.database !== undefined) {
      DatabaseRef.encode(message.database, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableList {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.database = DatabaseRef.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TableList>): TableList {
    return TableList.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableList>): TableList {
    const message = createBaseTableList();
    message.database = (object.database !== undefined && object.database !== null)
      ? DatabaseRef.fromPartial(object.database)
      : undefined;
    return message;
  },
};

function createBaseExpression(): Expression {
  return {
    literal: undefined,
    field: undefined,
    variable: undefined,
    binary: undefined,
    unary: undefined,
    match: undefined,
    subquery: undefined,
  };
}

export const Expression: MessageFns<Expression> = {
  encode(message: Expression, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.literal !== undefined) {
      Datum.encode(message.literal, writer.uint32(10).fork()).join();
    }
    if (message.field !== undefined) {
      FieldRef.encode(message.field, writer.uint32(18).fork()).join();
    }
    if (message.variable !== undefined) {
      Variable.encode(message.variable, writer.uint32(26).fork()).join();
    }
    if (message.binary !== undefined) {
      BinaryOp.encode(message.binary, writer.uint32(34).fork()).join();
    }
    if (message.unary !== undefined) {
      UnaryOp.encode(message.unary, writer.uint32(42).fork()).join();
    }
    if (message.match !== undefined) {
      MatchExpr.encode(message.match, writer.uint32(82).fork()).join();
    }
    if (message.subquery !== undefined) {
      Query.encode(message.subquery, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Expression {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.literal = Datum.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.field = FieldRef.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.variable = Variable.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.binary = BinaryOp.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.unary = UnaryOp.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.match = MatchExpr.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.subquery = Query.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Expression>): Expression {
    return Expression.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Expression>): Expression {
    const message = createBaseExpression();
    message.literal = (object.literal !== undefined && object.literal !== null)
      ? Datum.fromPartial(object.literal)
      : undefined;
    message.field = (object.field !== undefined && object.field !== null)
      ? FieldRef.fromPartial(object.field)
      : undefined;
    message.variable = (object.variable !== undefined && object.variable !== null)
      ? Variable.fromPartial(object.variable)
      : undefined;
    message.binary = (object.binary !== undefined && object.binary !== null)
      ? BinaryOp.fromPartial(object.binary)
      : undefined;
    message.unary = (object.unary !== undefined && object.unary !== null)
      ? UnaryOp.fromPartial(object.unary)
      : undefined;
    message.match = (object.match !== undefined && object.match !== null)
      ? MatchExpr.fromPartial(object.match)
      : undefined;
    message.subquery = (object.subquery !== undefined && object.subquery !== null)
      ? Query.fromPartial(object.subquery)
      : undefined;
    return message;
  },
};

function createBaseVariable(): Variable {
  return { name: "" };
}

export const Variable: MessageFns<Variable> = {
  encode(message: Variable, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Variable {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Variable>): Variable {
    return Variable.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Variable>): Variable {
    const message = createBaseVariable();
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseBinaryOp(): BinaryOp {
  return { op: 0, left: undefined, right: undefined };
}

export const BinaryOp: MessageFns<BinaryOp> = {
  encode(message: BinaryOp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    if (message.left !== undefined) {
      Expression.encode(message.left, writer.uint32(18).fork()).join();
    }
    if (message.right !== undefined) {
      Expression.encode(message.right, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BinaryOp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBinaryOp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.op = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.left = Expression.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.right = Expression.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<BinaryOp>): BinaryOp {
    return BinaryOp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BinaryOp>): BinaryOp {
    const message = createBaseBinaryOp();
    message.op = object.op ?? 0;
    message.left = (object.left !== undefined && object.left !== null)
      ? Expression.fromPartial(object.left)
      : undefined;
    message.right = (object.right !== undefined && object.right !== null)
      ? Expression.fromPartial(object.right)
      : undefined;
    return message;
  },
};

function createBaseUnaryOp(): UnaryOp {
  return { op: 0, expr: undefined };
}

export const UnaryOp: MessageFns<UnaryOp> = {
  encode(message: UnaryOp, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.op !== 0) {
      writer.uint32(8).int32(message.op);
    }
    if (message.expr !== undefined) {
      Expression.encode(message.expr, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnaryOp {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnaryOp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.op = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.expr = Expression.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<UnaryOp>): UnaryOp {
    return UnaryOp.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UnaryOp>): UnaryOp {
    const message = createBaseUnaryOp();
    message.op = object.op ?? 0;
    message.expr = (object.expr !== undefined && object.expr !== null)
      ? Expression.fromPartial(object.expr)
      : undefined;
    return message;
  },
};

function createBaseMatchExpr(): MatchExpr {
  return { value: undefined, pattern: "", flags: "" };
}

export const MatchExpr: MessageFns<MatchExpr> = {
  encode(message: MatchExpr, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      Expression.encode(message.value, writer.uint32(10).fork()).join();
    }
    if (message.pattern !== "") {
      writer.uint32(18).string(message.pattern);
    }
    if (message.flags !== "") {
      writer.uint32(26).string(message.flags);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MatchExpr {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatchExpr();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = Expression.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pattern = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.flags = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MatchExpr>): MatchExpr {
    return MatchExpr.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MatchExpr>): MatchExpr {
    const message = createBaseMatchExpr();
    message.value = (object.value !== undefined && object.value !== null)
      ? Expression.fromPartial(object.value)
      : undefined;
    message.pattern = object.pattern ?? "";
    message.flags = object.flags ?? "";
    return message;
  },
};

function createBaseSubquery(): Subquery {
  return { query: undefined };
}

export const Subquery: MessageFns<Subquery> = {
  encode(message: Subquery, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== undefined) {
      Query.encode(message.query, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Subquery {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubquery();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = Query.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Subquery>): Subquery {
    return Subquery.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Subquery>): Subquery {
    const message = createBaseSubquery();
    message.query = (object.query !== undefined && object.query !== null) ? Query.fromPartial(object.query) : undefined;
    return message;
  },
};

function createBaseResponse(): Response {
  return {
    metadata: undefined,
    query: undefined,
    error: undefined,
    authResult: undefined,
    pong: undefined,
    plan: undefined,
  };
}

export const Response: MessageFns<Response> = {
  encode(message: Response, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      ResponseMetadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    if (message.query !== undefined) {
      QueryResult.encode(message.query, writer.uint32(18).fork()).join();
    }
    if (message.error !== undefined) {
      ErrorInfo.encode(message.error, writer.uint32(26).fork()).join();
    }
    if (message.authResult !== undefined) {
      AuthResult.encode(message.authResult, writer.uint32(34).fork()).join();
    }
    if (message.pong !== undefined) {
      PingResult.encode(message.pong, writer.uint32(42).fork()).join();
    }
    if (message.plan !== undefined) {
      QueryPlan.encode(message.plan, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Response {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.query = QueryResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = ErrorInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.authResult = AuthResult.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.pong = PingResult.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.plan = QueryPlan.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Response>): Response {
    return Response.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Response>): Response {
    const message = createBaseResponse();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ResponseMetadata.fromPartial(object.metadata)
      : undefined;
    message.query = (object.query !== undefined && object.query !== null)
      ? QueryResult.fromPartial(object.query)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? ErrorInfo.fromPartial(object.error)
      : undefined;
    message.authResult = (object.authResult !== undefined && object.authResult !== null)
      ? AuthResult.fromPartial(object.authResult)
      : undefined;
    message.pong = (object.pong !== undefined && object.pong !== null)
      ? PingResult.fromPartial(object.pong)
      : undefined;
    message.plan = (object.plan !== undefined && object.plan !== null) ? QueryPlan.fromPartial(object.plan) : undefined;
    return message;
  },
};

function createBaseResponseMetadata(): ResponseMetadata {
  return { queryId: "", timestamp: "0", serverVersion: "" };
}

export const ResponseMetadata: MessageFns<ResponseMetadata> = {
  encode(message: ResponseMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.queryId !== "") {
      writer.uint32(10).string(message.queryId);
    }
    if (message.timestamp !== "0") {
      writer.uint32(16).uint64(message.timestamp);
    }
    if (message.serverVersion !== "") {
      writer.uint32(26).string(message.serverVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.queryId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestamp = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.serverVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ResponseMetadata>): ResponseMetadata {
    return ResponseMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ResponseMetadata>): ResponseMetadata {
    const message = createBaseResponseMetadata();
    message.queryId = object.queryId ?? "";
    message.timestamp = object.timestamp ?? "0";
    message.serverVersion = object.serverVersion ?? "";
    return message;
  },
};

function createBaseErrorInfo(): ErrorInfo {
  return { code: 0, message: "", type: "", line: 0, column: 0 };
}

export const ErrorInfo: MessageFns<ErrorInfo> = {
  encode(message: ErrorInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).uint32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.line !== 0) {
      writer.uint32(32).uint32(message.line);
    }
    if (message.column !== 0) {
      writer.uint32(40).uint32(message.column);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.line = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.column = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ErrorInfo>): ErrorInfo {
    return ErrorInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ErrorInfo>): ErrorInfo {
    const message = createBaseErrorInfo();
    message.code = object.code ?? 0;
    message.message = object.message ?? "";
    message.type = object.type ?? "";
    message.line = object.line ?? 0;
    message.column = object.column ?? 0;
    return message;
  },
};

function createBaseQueryResult(): QueryResult {
  return {
    literal: undefined,
    get: undefined,
    getAll: undefined,
    table: undefined,
    filter: undefined,
    orderBy: undefined,
    limit: undefined,
    skip: undefined,
    count: undefined,
    pluck: undefined,
    insert: undefined,
    delete: undefined,
    update: undefined,
    databaseCreate: undefined,
    databaseDrop: undefined,
    databaseList: undefined,
    tableCreate: undefined,
    tableDrop: undefined,
    tableList: undefined,
  };
}

export const QueryResult: MessageFns<QueryResult> = {
  encode(message: QueryResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.literal !== undefined) {
      LiteralResult.encode(message.literal, writer.uint32(10).fork()).join();
    }
    if (message.get !== undefined) {
      GetResult.encode(message.get, writer.uint32(18).fork()).join();
    }
    if (message.getAll !== undefined) {
      GetAllResult.encode(message.getAll, writer.uint32(26).fork()).join();
    }
    if (message.table !== undefined) {
      TableScanResult.encode(message.table, writer.uint32(34).fork()).join();
    }
    if (message.filter !== undefined) {
      FilterResult.encode(message.filter, writer.uint32(42).fork()).join();
    }
    if (message.orderBy !== undefined) {
      OrderByResult.encode(message.orderBy, writer.uint32(50).fork()).join();
    }
    if (message.limit !== undefined) {
      LimitResult.encode(message.limit, writer.uint32(58).fork()).join();
    }
    if (message.skip !== undefined) {
      SkipResult.encode(message.skip, writer.uint32(66).fork()).join();
    }
    if (message.count !== undefined) {
      CountResult.encode(message.count, writer.uint32(74).fork()).join();
    }
    if (message.pluck !== undefined) {
      PluckResult.encode(message.pluck, writer.uint32(154).fork()).join();
    }
    if (message.insert !== undefined) {
      InsertResult.encode(message.insert, writer.uint32(82).fork()).join();
    }
    if (message.delete !== undefined) {
      DeleteResult.encode(message.delete, writer.uint32(90).fork()).join();
    }
    if (message.update !== undefined) {
      UpdateResult.encode(message.update, writer.uint32(98).fork()).join();
    }
    if (message.databaseCreate !== undefined) {
      DatabaseCreateResult.encode(message.databaseCreate, writer.uint32(106).fork()).join();
    }
    if (message.databaseDrop !== undefined) {
      DatabaseDropResult.encode(message.databaseDrop, writer.uint32(114).fork()).join();
    }
    if (message.databaseList !== undefined) {
      DatabaseListResult.encode(message.databaseList, writer.uint32(122).fork()).join();
    }
    if (message.tableCreate !== undefined) {
      TableCreateResult.encode(message.tableCreate, writer.uint32(130).fork()).join();
    }
    if (message.tableDrop !== undefined) {
      TableDropResult.encode(message.tableDrop, writer.uint32(138).fork()).join();
    }
    if (message.tableList !== undefined) {
      TableListResult.encode(message.tableList, writer.uint32(146).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.literal = LiteralResult.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.get = GetResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.getAll = GetAllResult.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.table = TableScanResult.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.filter = FilterResult.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.orderBy = OrderByResult.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.limit = LimitResult.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.skip = SkipResult.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.count = CountResult.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.pluck = PluckResult.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.insert = InsertResult.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.delete = DeleteResult.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.update = UpdateResult.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.databaseCreate = DatabaseCreateResult.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.databaseDrop = DatabaseDropResult.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.databaseList = DatabaseListResult.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.tableCreate = TableCreateResult.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.tableDrop = TableDropResult.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.tableList = TableListResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<QueryResult>): QueryResult {
    return QueryResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryResult>): QueryResult {
    const message = createBaseQueryResult();
    message.literal = (object.literal !== undefined && object.literal !== null)
      ? LiteralResult.fromPartial(object.literal)
      : undefined;
    message.get = (object.get !== undefined && object.get !== null) ? GetResult.fromPartial(object.get) : undefined;
    message.getAll = (object.getAll !== undefined && object.getAll !== null)
      ? GetAllResult.fromPartial(object.getAll)
      : undefined;
    message.table = (object.table !== undefined && object.table !== null)
      ? TableScanResult.fromPartial(object.table)
      : undefined;
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? FilterResult.fromPartial(object.filter)
      : undefined;
    message.orderBy = (object.orderBy !== undefined && object.orderBy !== null)
      ? OrderByResult.fromPartial(object.orderBy)
      : undefined;
    message.limit = (object.limit !== undefined && object.limit !== null)
      ? LimitResult.fromPartial(object.limit)
      : undefined;
    message.skip = (object.skip !== undefined && object.skip !== null)
      ? SkipResult.fromPartial(object.skip)
      : undefined;
    message.count = (object.count !== undefined && object.count !== null)
      ? CountResult.fromPartial(object.count)
      : undefined;
    message.pluck = (object.pluck !== undefined && object.pluck !== null)
      ? PluckResult.fromPartial(object.pluck)
      : undefined;
    message.insert = (object.insert !== undefined && object.insert !== null)
      ? InsertResult.fromPartial(object.insert)
      : undefined;
    message.delete = (object.delete !== undefined && object.delete !== null)
      ? DeleteResult.fromPartial(object.delete)
      : undefined;
    message.update = (object.update !== undefined && object.update !== null)
      ? UpdateResult.fromPartial(object.update)
      : undefined;
    message.databaseCreate = (object.databaseCreate !== undefined && object.databaseCreate !== null)
      ? DatabaseCreateResult.fromPartial(object.databaseCreate)
      : undefined;
    message.databaseDrop = (object.databaseDrop !== undefined && object.databaseDrop !== null)
      ? DatabaseDropResult.fromPartial(object.databaseDrop)
      : undefined;
    message.databaseList = (object.databaseList !== undefined && object.databaseList !== null)
      ? DatabaseListResult.fromPartial(object.databaseList)
      : undefined;
    message.tableCreate = (object.tableCreate !== undefined && object.tableCreate !== null)
      ? TableCreateResult.fromPartial(object.tableCreate)
      : undefined;
    message.tableDrop = (object.tableDrop !== undefined && object.tableDrop !== null)
      ? TableDropResult.fromPartial(object.tableDrop)
      : undefined;
    message.tableList = (object.tableList !== undefined && object.tableList !== null)
      ? TableListResult.fromPartial(object.tableList)
      : undefined;
    return message;
  },
};

function createBaseLiteralResult(): LiteralResult {
  return { value: undefined };
}

export const LiteralResult: MessageFns<LiteralResult> = {
  encode(message: LiteralResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      Datum.encode(message.value, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LiteralResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLiteralResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = Datum.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<LiteralResult>): LiteralResult {
    return LiteralResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LiteralResult>): LiteralResult {
    const message = createBaseLiteralResult();
    message.value = (object.value !== undefined && object.value !== null) ? Datum.fromPartial(object.value) : undefined;
    return message;
  },
};

function createBaseGetResult(): GetResult {
  return { document: undefined };
}

export const GetResult: MessageFns<GetResult> = {
  encode(message: GetResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.document !== undefined) {
      Datum.encode(message.document, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.document = Datum.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetResult>): GetResult {
    return GetResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetResult>): GetResult {
    const message = createBaseGetResult();
    message.document = (object.document !== undefined && object.document !== null)
      ? Datum.fromPartial(object.document)
      : undefined;
    return message;
  },
};

function createBaseGetAllResult(): GetAllResult {
  return { documents: [], cursor: undefined };
}

export const GetAllResult: MessageFns<GetAllResult> = {
  encode(message: GetAllResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.documents) {
      Datum.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.cursor !== undefined) {
      Cursor.encode(message.cursor, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetAllResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.documents.push(Datum.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cursor = Cursor.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetAllResult>): GetAllResult {
    return GetAllResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetAllResult>): GetAllResult {
    const message = createBaseGetAllResult();
    message.documents = object.documents?.map((e) => Datum.fromPartial(e)) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? Cursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseTableScanResult(): TableScanResult {
  return { documents: [], cursor: undefined };
}

export const TableScanResult: MessageFns<TableScanResult> = {
  encode(message: TableScanResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.documents) {
      Datum.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.cursor !== undefined) {
      Cursor.encode(message.cursor, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableScanResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableScanResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.documents.push(Datum.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cursor = Cursor.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TableScanResult>): TableScanResult {
    return TableScanResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableScanResult>): TableScanResult {
    const message = createBaseTableScanResult();
    message.documents = object.documents?.map((e) => Datum.fromPartial(e)) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? Cursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseFilterResult(): FilterResult {
  return { documents: [], cursor: undefined };
}

export const FilterResult: MessageFns<FilterResult> = {
  encode(message: FilterResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.documents) {
      Datum.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.cursor !== undefined) {
      Cursor.encode(message.cursor, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FilterResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilterResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.documents.push(Datum.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cursor = Cursor.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<FilterResult>): FilterResult {
    return FilterResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FilterResult>): FilterResult {
    const message = createBaseFilterResult();
    message.documents = object.documents?.map((e) => Datum.fromPartial(e)) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? Cursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseOrderByResult(): OrderByResult {
  return { documents: [], cursor: undefined };
}

export const OrderByResult: MessageFns<OrderByResult> = {
  encode(message: OrderByResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.documents) {
      Datum.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.cursor !== undefined) {
      Cursor.encode(message.cursor, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderByResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderByResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.documents.push(Datum.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cursor = Cursor.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<OrderByResult>): OrderByResult {
    return OrderByResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrderByResult>): OrderByResult {
    const message = createBaseOrderByResult();
    message.documents = object.documents?.map((e) => Datum.fromPartial(e)) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? Cursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseLimitResult(): LimitResult {
  return { documents: [], cursor: undefined };
}

export const LimitResult: MessageFns<LimitResult> = {
  encode(message: LimitResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.documents) {
      Datum.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.cursor !== undefined) {
      Cursor.encode(message.cursor, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LimitResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLimitResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.documents.push(Datum.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cursor = Cursor.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<LimitResult>): LimitResult {
    return LimitResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LimitResult>): LimitResult {
    const message = createBaseLimitResult();
    message.documents = object.documents?.map((e) => Datum.fromPartial(e)) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? Cursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseSkipResult(): SkipResult {
  return { documents: [], cursor: undefined };
}

export const SkipResult: MessageFns<SkipResult> = {
  encode(message: SkipResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.documents) {
      Datum.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.cursor !== undefined) {
      Cursor.encode(message.cursor, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkipResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkipResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.documents.push(Datum.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cursor = Cursor.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SkipResult>): SkipResult {
    return SkipResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SkipResult>): SkipResult {
    const message = createBaseSkipResult();
    message.documents = object.documents?.map((e) => Datum.fromPartial(e)) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? Cursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseCountResult(): CountResult {
  return { count: "0" };
}

export const CountResult: MessageFns<CountResult> = {
  encode(message: CountResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.count !== "0") {
      writer.uint32(8).uint64(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CountResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCountResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.count = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<CountResult>): CountResult {
    return CountResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CountResult>): CountResult {
    const message = createBaseCountResult();
    message.count = object.count ?? "0";
    return message;
  },
};

function createBasePluckResult(): PluckResult {
  return { documents: [], cursor: undefined };
}

export const PluckResult: MessageFns<PluckResult> = {
  encode(message: PluckResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.documents) {
      Datum.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.cursor !== undefined) {
      Cursor.encode(message.cursor, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PluckResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePluckResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.documents.push(Datum.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cursor = Cursor.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PluckResult>): PluckResult {
    return PluckResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PluckResult>): PluckResult {
    const message = createBasePluckResult();
    message.documents = object.documents?.map((e) => Datum.fromPartial(e)) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? Cursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseInsertResult(): InsertResult {
  return { inserted: "0", generatedKeys: [] };
}

export const InsertResult: MessageFns<InsertResult> = {
  encode(message: InsertResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inserted !== "0") {
      writer.uint32(8).uint64(message.inserted);
    }
    for (const v of message.generatedKeys) {
      Datum.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InsertResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInsertResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.inserted = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.generatedKeys.push(Datum.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<InsertResult>): InsertResult {
    return InsertResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InsertResult>): InsertResult {
    const message = createBaseInsertResult();
    message.inserted = object.inserted ?? "0";
    message.generatedKeys = object.generatedKeys?.map((e) => Datum.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteResult(): DeleteResult {
  return { deleted: "0" };
}

export const DeleteResult: MessageFns<DeleteResult> = {
  encode(message: DeleteResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deleted !== "0") {
      writer.uint32(8).uint64(message.deleted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.deleted = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DeleteResult>): DeleteResult {
    return DeleteResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteResult>): DeleteResult {
    const message = createBaseDeleteResult();
    message.deleted = object.deleted ?? "0";
    return message;
  },
};

function createBaseUpdateResult(): UpdateResult {
  return { updated: "0" };
}

export const UpdateResult: MessageFns<UpdateResult> = {
  encode(message: UpdateResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.updated !== "0") {
      writer.uint32(8).uint64(message.updated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.updated = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<UpdateResult>): UpdateResult {
    return UpdateResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateResult>): UpdateResult {
    const message = createBaseUpdateResult();
    message.updated = object.updated ?? "0";
    return message;
  },
};

function createBaseDatabaseCreateResult(): DatabaseCreateResult {
  return { created: "0" };
}

export const DatabaseCreateResult: MessageFns<DatabaseCreateResult> = {
  encode(message: DatabaseCreateResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.created !== "0") {
      writer.uint32(8).uint64(message.created);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseCreateResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseCreateResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.created = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DatabaseCreateResult>): DatabaseCreateResult {
    return DatabaseCreateResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatabaseCreateResult>): DatabaseCreateResult {
    const message = createBaseDatabaseCreateResult();
    message.created = object.created ?? "0";
    return message;
  },
};

function createBaseDatabaseDropResult(): DatabaseDropResult {
  return { dropped: "0" };
}

export const DatabaseDropResult: MessageFns<DatabaseDropResult> = {
  encode(message: DatabaseDropResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dropped !== "0") {
      writer.uint32(8).uint64(message.dropped);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseDropResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseDropResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.dropped = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DatabaseDropResult>): DatabaseDropResult {
    return DatabaseDropResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatabaseDropResult>): DatabaseDropResult {
    const message = createBaseDatabaseDropResult();
    message.dropped = object.dropped ?? "0";
    return message;
  },
};

function createBaseDatabaseListResult(): DatabaseListResult {
  return { databases: [], cursor: undefined };
}

export const DatabaseListResult: MessageFns<DatabaseListResult> = {
  encode(message: DatabaseListResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.databases) {
      writer.uint32(10).string(v!);
    }
    if (message.cursor !== undefined) {
      Cursor.encode(message.cursor, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DatabaseListResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDatabaseListResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.databases.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cursor = Cursor.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DatabaseListResult>): DatabaseListResult {
    return DatabaseListResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DatabaseListResult>): DatabaseListResult {
    const message = createBaseDatabaseListResult();
    message.databases = object.databases?.map((e) => e) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? Cursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBaseTableCreateResult(): TableCreateResult {
  return { created: "0" };
}

export const TableCreateResult: MessageFns<TableCreateResult> = {
  encode(message: TableCreateResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.created !== "0") {
      writer.uint32(8).uint64(message.created);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableCreateResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableCreateResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.created = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TableCreateResult>): TableCreateResult {
    return TableCreateResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableCreateResult>): TableCreateResult {
    const message = createBaseTableCreateResult();
    message.created = object.created ?? "0";
    return message;
  },
};

function createBaseTableDropResult(): TableDropResult {
  return { dropped: "0" };
}

export const TableDropResult: MessageFns<TableDropResult> = {
  encode(message: TableDropResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dropped !== "0") {
      writer.uint32(8).uint64(message.dropped);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableDropResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableDropResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.dropped = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TableDropResult>): TableDropResult {
    return TableDropResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableDropResult>): TableDropResult {
    const message = createBaseTableDropResult();
    message.dropped = object.dropped ?? "0";
    return message;
  },
};

function createBaseTableListResult(): TableListResult {
  return { tables: [], cursor: undefined };
}

export const TableListResult: MessageFns<TableListResult> = {
  encode(message: TableListResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tables) {
      writer.uint32(10).string(v!);
    }
    if (message.cursor !== undefined) {
      Cursor.encode(message.cursor, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TableListResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableListResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tables.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cursor = Cursor.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TableListResult>): TableListResult {
    return TableListResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TableListResult>): TableListResult {
    const message = createBaseTableListResult();
    message.tables = object.tables?.map((e) => e) || [];
    message.cursor = (object.cursor !== undefined && object.cursor !== null)
      ? Cursor.fromPartial(object.cursor)
      : undefined;
    return message;
  },
};

function createBasePingResult(): PingResult {
  return { timestamp: "0", latencyMs: 0 };
}

export const PingResult: MessageFns<PingResult> = {
  encode(message: PingResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== "0") {
      writer.uint32(8).uint64(message.timestamp);
    }
    if (message.latencyMs !== 0) {
      writer.uint32(16).uint32(message.latencyMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PingResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePingResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestamp = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.latencyMs = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PingResult>): PingResult {
    return PingResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PingResult>): PingResult {
    const message = createBasePingResult();
    message.timestamp = object.timestamp ?? "0";
    message.latencyMs = object.latencyMs ?? 0;
    return message;
  },
};

function createBaseQueryPlan(): QueryPlan {
  return { nodes: [], statistics: undefined };
}

export const QueryPlan: MessageFns<QueryPlan> = {
  encode(message: QueryPlan, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nodes) {
      PlanNode.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.statistics !== undefined) {
      PlanStatistics.encode(message.statistics, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPlan {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPlan();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodes.push(PlanNode.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.statistics = PlanStatistics.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<QueryPlan>): QueryPlan {
    return QueryPlan.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryPlan>): QueryPlan {
    const message = createBaseQueryPlan();
    message.nodes = object.nodes?.map((e) => PlanNode.fromPartial(e)) || [];
    message.statistics = (object.statistics !== undefined && object.statistics !== null)
      ? PlanStatistics.fromPartial(object.statistics)
      : undefined;
    return message;
  },
};

function createBasePlanNode(): PlanNode {
  return { operation: "", properties: {}, children: [], estimatedCost: 0, estimatedRows: "0" };
}

export const PlanNode: MessageFns<PlanNode> = {
  encode(message: PlanNode, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.operation !== "") {
      writer.uint32(10).string(message.operation);
    }
    Object.entries(message.properties).forEach(([key, value]) => {
      PlanNode_PropertiesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    for (const v of message.children) {
      PlanNode.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.estimatedCost !== 0) {
      writer.uint32(33).double(message.estimatedCost);
    }
    if (message.estimatedRows !== "0") {
      writer.uint32(40).uint64(message.estimatedRows);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlanNode {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlanNode();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operation = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = PlanNode_PropertiesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.properties[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.children.push(PlanNode.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.estimatedCost = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.estimatedRows = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PlanNode>): PlanNode {
    return PlanNode.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlanNode>): PlanNode {
    const message = createBasePlanNode();
    message.operation = object.operation ?? "";
    message.properties = Object.entries(object.properties ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.children = object.children?.map((e) => PlanNode.fromPartial(e)) || [];
    message.estimatedCost = object.estimatedCost ?? 0;
    message.estimatedRows = object.estimatedRows ?? "0";
    return message;
  },
};

function createBasePlanNode_PropertiesEntry(): PlanNode_PropertiesEntry {
  return { key: "", value: "" };
}

export const PlanNode_PropertiesEntry: MessageFns<PlanNode_PropertiesEntry> = {
  encode(message: PlanNode_PropertiesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlanNode_PropertiesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlanNode_PropertiesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PlanNode_PropertiesEntry>): PlanNode_PropertiesEntry {
    return PlanNode_PropertiesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlanNode_PropertiesEntry>): PlanNode_PropertiesEntry {
    const message = createBasePlanNode_PropertiesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePlanStatistics(): PlanStatistics {
  return { planningTimeMs: 0, executionTimeMs: 0, rowsExamined: "0", rowsReturned: "0", bytesRead: "0" };
}

export const PlanStatistics: MessageFns<PlanStatistics> = {
  encode(message: PlanStatistics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.planningTimeMs !== 0) {
      writer.uint32(8).uint32(message.planningTimeMs);
    }
    if (message.executionTimeMs !== 0) {
      writer.uint32(16).uint32(message.executionTimeMs);
    }
    if (message.rowsExamined !== "0") {
      writer.uint32(24).uint64(message.rowsExamined);
    }
    if (message.rowsReturned !== "0") {
      writer.uint32(32).uint64(message.rowsReturned);
    }
    if (message.bytesRead !== "0") {
      writer.uint32(40).uint64(message.bytesRead);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlanStatistics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlanStatistics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.planningTimeMs = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.executionTimeMs = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.rowsExamined = reader.uint64().toString();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rowsReturned = reader.uint64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.bytesRead = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PlanStatistics>): PlanStatistics {
    return PlanStatistics.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PlanStatistics>): PlanStatistics {
    const message = createBasePlanStatistics();
    message.planningTimeMs = object.planningTimeMs ?? 0;
    message.executionTimeMs = object.executionTimeMs ?? 0;
    message.rowsExamined = object.rowsExamined ?? "0";
    message.rowsReturned = object.rowsReturned ?? "0";
    message.bytesRead = object.bytesRead ?? "0";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
